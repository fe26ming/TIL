**파랑 : 내 생각**

**빨강 : 강조**

- 목차

# 0. 들어가면서

코드 품질을 측정하는 유일한 척도 = **분 당 내지리는 WTF! 횟수 (분 당 야발지수) - pg0**

난관에 부딪힐 때 옳은 문 뒤에 있으려면 어떻게 해야 할까? 답은 **장인 정신**

**장인 정신**을 익히는 과정은 **두 단계**로 나뉜다. 바로 **이론(1)**과 **실전(2)이다.**

이론 = 원칙, 패턴, 기법, 경험

실전 = 열심히 일하고 연습해 지식을 몸과 마음으로 체득

## 이 책은 세부분으로 나눠진다.

처음 ⇒ 깨끗한 코드를 작성하는 **원칙, 패턴, 실기**

둘째 ⇒ **여러 사례 연구**를  통해 코드를 깨끗하게 고치는, 즉 문제가 있는 코드를 문제가 더 적은 코드로 바꾸는 **연습**이다.

셋째 ⇒ 결말, 사례 연구를 만들면서 수집한 **냄새와 휴리스틱**을 마지막 장에서 열거한다.

# 1. 깨끗한 코드 pg1

## 코드가 존재하리라

코드란 **요구사항을 상세히 표현하는 수단**이다. pg -3

**—> 코드로 무엇을 표현할지는 정해져 있다. 정확하고 명확하게 요구사항을 표현하는 것!**

## 나쁜 코드

회사가 망한 원인은 바로 **나쁜 코드 탓**이다.

우리 모두는 자신이 짠 쓰레기 코드를 쳐다보며 나중에 손보겠다고 생각한  경험이 있다. 우리 모두는 대충 짠 프로그램이 돌아간다는 사실에 안도감을 느끼며 그래도 안 돌아가는 프로그램보다 돌아가는 쓰레기가 좋다고 스스로를 위로한 경험이 있다. 다시 돌아와 나중에 정리하겠다고 다짐했었다. 물론 그때 그 시절 우리는 **르블랑의 법칙**을 몰랐다. **나중은 결코 오지 않는다.**

> **르블라의 법칙 :**
> 
> 
> 나중은 절대 돌아오지 않는다는 법칙입니다.
> 
> 나쁜 코드를 구현하면 나중은 오지 않지 않습니다.
> 
>  출처 - [https://hoxi777.tistory.com/2](https://hoxi777.tistory.com/2)
> 

## 나쁜 코드로 치르는 대가

**시간을 들여 깨끗한 코드를 만드는 노력**이 비용을 절감하는 방법일 뿐만 아니라 **전문가로서 살아남는 길**이라는 사실을 인정하라 

> **오버워치1의 잘못된 설계** - [https://www.youtube.com/watch?v=gTgGUEgbLLE&ab_channel=김성회의G식백과](https://www.youtube.com/watch?v=gTgGUEgbLLE&ab_channel=%EA%B9%80%EC%84%B1%ED%9A%8C%EC%9D%98G%EC%8B%9D%EB%B0%B1%EA%B3%BC)
> 
> 
> 
> 오버워치 게임은 처음 장르 설계와 완전 다른 게임을 억지로 뜯어 고쳐서 만든 게임이었다. 유지 보수성이 떨어지고 잦은 에러가 생겨났다.
> 
> → 이를 해결하기 위해서 오버워치 2로 새로운 게임을 개발해야 했다. 
> 

## 태도

프로그래머는 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따른 행동은 전문가답지 못하다.

## 원초적 난제

기한을 맞춘는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은, 언제나 코드를 최대한 꺠끗하게 유지하는 습관이다.

## 깨끗한 코드라는 예술?

깨끗한 코드를 작성하려면 ‘**청결’**이라는 힘겹게 습득한 감각을 활용해 자잘한 기법들을 적용하는 **절제**와 **규율**이 필요하다. 열쇠는 ‘**코드 감각**’이다.

## 깨끗한 코드란?

> **논리가 간단**해야 **버그가 숨어들지 못한다**.
> 
> 
> **의존성**을 최대한 **줄여**야 **유지보수**가 **쉬워**진다.
> 
> **오류**는 **명백한 전략**에 의거해 철저히 처리한다.
> 
> 성능을 최적으로 유지해야 사람들이 원칙 없는 최적화로 코드를 망치려는 **유혹**에 빠지지 않는다.
> 
>  - 비야네 스트롭스트룹, C++의 창시자
> 

프로그래머들이 대충 넘어가는 부분 중 하나가 오류처리다.

메모리 누수, 경쟁상대, 일관성 없는 명명법이 또 다른 예다. 한 마디로 요약하면, 깨끗한 코드는 세세한 사항까지 꼼꼼하게 처리하는 코드다.

깨끗한 코드는 한 가지에 ‘집중’한다.

> **깨끗한 코드는 잘 쓴 문장처럼 읽힌다.**
> 
> 
>   - 그래디 부치
> 

좋은 소설과 마찬가지로 깨끗한 코드는 해결할 문제의 긴장을 명확히 드러내야 한다.

코드는 추측이 아니라 사실에 기반해야 한다.

> 단위 테스트 케이스와 인수 테스트 케이스가 존재한다.
> 
> 
> 의존성은 최소이며 각 의존성을 명확히 정의한다.
> 
>  - 큰 데이브 토마스
> 

데이브는 깨끗한 코드란 다른 사람이 고치기 쉽다고 단언한다.

실제로 일기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다.

 

> 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다.
> 
> 
>    - 마이클 페더스
> 

> 론 제프리스
> 
- 모든 테스트를 통과한다.
- 중복이 없다.
- 시스템 내 모든 설계 아이디어를 표현한다.
- 클래스, 메서드, 함수 등을 최대한 줄인다.

중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. 내게는 이 세 가지가 꺠끗한 코드를 만드는 비결이다.

> 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.
> 
> 
>     - 워드 커닝햄
> 

언어를 단순하게 보이도록 만드는 책임이 우리에게 있다는 뜻이다!

## 우리들 생각

이 책은 나와 내 동료들이 생각하는 바를 끔찍할 정도로 상세히 설명한다. **깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스**를 만드는 방법을 소개한다.

## 우리는 저자다

우리는 저다. 저자에게는 독자가 있다. 그리고 저자에게는 독자와 잘 소통할 책임도 있다. 다음에 코드를 짤 때는 자신이 저자라는 사실을, 여러분의 노력을 보고 판단을 내릴 독자가 있다는 사실을 기억하길 바란다.

새 코드를 짜면서 우리는 끊임없이 **기존 코드를 읽는다.**

## 보이스카우트 규칙

캠프장을 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라

체크아웃을할 때보다 좀 더 깨끗한 코드를 체크인 한다면 코드는 절대 나빠지지 않는다.

한꺼번에 많은 시간과 노력을 투자해 코드를 정리할 필요가 없다. 변수 이름 하나를 개선하고, 조금 긴 함수 하나를 분할하고, 약간의 중복을 제거하고, 복잡한 if 문 하나를 정리하면 충분하다.

 시간이 지날수록 코드가 좋아지는 프로젝트에서 작업한다고 상상해보라! 전문가라면 너무도 당연하지 않은가! **지속적인 개선이야말로 전문가 정신의 본질이 아니던가?**

## 프리퀄과 원칙

SRP, OCP, DIP

## 결론

이 책을 읽는다고 뛰어난 프로그래머가 된다는 보장은 없다. ‘코드 감각’을 확실히 얻는다는 보장도 없다. **단지 뛰어난 프로그래머가 생각하는 방식과 그들이 사용하는 기술과 기교와 도구를 소개할 뿐이다.**

# 정리

이 책은 어떻게 하면 좋은 코드를 짜는지에 대해서 많은 정말 대단한 선생님들의 생각이 담겨있다. 그들의 철학과 노하우를 습득하는 것은 좋은 경험이다. 이러한 경험을 직접 체득하기 위해서는 얼마나 많은 시간과 노력이 필요할 지 모른다. 

지금은 이해가 되지 않을 지도 모르지만 하나하나 읽으면서 소화해보자.